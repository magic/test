<!DOCTYPE html>@magic/test{"@context":"http://schema.org","@type":"website","name":"@magic/test"}Skip to Content@magic/testgetting startedtest suiteswriting testsutility functionsusage@magic/testsimple tests with lots of utility. ecmascript modules only. runs ecmascript module tests without transpilation. unbelievably fast.getting startedbe in a nodejs project.installcopynpm i --save-dev --save-exact @magic/testcopy// create test/functionName.mjsimport yourTest from &#39;../path/to/your/file.mjs&#39;export default [  { fn: () =&gt; true, expect: true, info: &#39;true is true&#39; },  // note that the yourTest function will be called automagically  { fn: yourTest, expect: true, info: &#39;hope this will work ;)&#39;}]npm scriptsedit package.jsoncopy{  &quot;scripts&quot;: {    &quot;test&quot;: &quot;t -p&quot;, // quick test, only failing tests log    &quot;coverage&quot;: &quot;t&quot;, // get full test output and coverage reports  }}repeated for easy copy pasting (without comments)copy&quot;scripts&quot;: {    &quot;test&quot;: &quot;t -p&quot;,    &quot;coverage&quot;: &quot;t&quot;,  }quick testswithout coveragecopy// run the tests:npm test// example output:// (failing tests will print, passing tests are silent)// ### Testing package: @magic/test// Ran 2 tests. Passed 2/2 100%coverage@magic/test will automagically generate coverage reports if it is not called with the -p flag.data/fs driven test suite creation:expectations for optimal test messages:src and test directories have the same structure and files
tests one src file per test file
tests one function per suite
tests one feature per testFilesystem based namingthe following directory structure:copy./test/  ./suite1.mjs  ./suite2.mjsyields the same result as exporting the following from ./test/index.mjsData driven namingcopyimport suite1 from &#39;./suite1&#39;import suite2 from &#39;./suite2&#39;export default {  suite1,  suite2,}Important - File mappingsif test/index.mjs exists, no other files will be loaded.
if test/lib/index.mjs exists, no other files from that subdirectory will be loaded.single testliteral value, function or promisecopyexport default { fn: true, expect: true, info: &#39;expect true to be true&#39; }// expect: true is the default and can be omittedexport default { fn: true, info: &#39;expect true to be true&#39; }// if fn is a function expect is the returned value of the functionexport default { fn: () =&gt; false, expect: false, info: &#39;expect true to be true&#39; }// if expect is a function the return value of the test get passed to itexport default { fn: false, expect: t =&gt; t === false, info: &#39;expect true to be true&#39; }// if fn is a promise the resolved value will be returnedexport default { fn: new Promise(r =&gt; r(true)), expect: true, info: &#39;expect true to be true&#39; }// if expects is a promise it will resolve before being compared to the fn return valueexport default { fn: true, expect: new Promise(r =&gt; r(true)), info: &#39;expect true to be true&#39; }// callback functions can be tested easily too:import { promise } from &#39;@magic/test&#39;const fnWithCallback = (err, arg, cb) =&gt; cb(err, arg)export default { fn: promise(fnWithCallback(null, &#39;arg&#39;, (e, a) =&gt; a)), expect: &quot;arg&quot; }testing typestypes can be compared using @magic/types@magic/types is a richly featured and thoroughly tested type library without dependencies.
it is exported from this library for convenience.copyimport { is } from &#39;@magic/test&#39;export default [  { fn: () =&gt; &#39;string&#39;,    expect: is.string,    info: &#39;test if a function returns a string&#39;  },  {    fn: () =&gt; &#39;string&#39;,    expect: is.length.equal(6),    info: &#39;test length of returned value&#39;  },  // !!! Testing for deep equality. simple.  {    fn: () =&gt; [1, 2, 3],    expect: is.deep.equal([1, 2, 3]),    info: &#39;deep compare arrays/objects for equality&#39;,  },  {    fn: () =&gt; { key: 1 },    expect: is.deep.different({ value: 1 }),    info: &#39;deep compare arrays/objects for difference&#39;,  },]caveat:if you want to test if a function is a function, you need to wrap the function in a function.
this is because functions passed to fn get executed automatically.copyimport { is } from &#39;@magic/test&#39;const fnToTest = () =&gt; {}// both the tests will work as expectedexport default [  {    fn: () =&gt; fnToTest,    expect: is.function,    info: &#39;function is a function&#39;,  },  {    fn: is.fn(fnToTest), // returns true    // we do not set expect: true, since that is the default    info: &#39;function is a function&#39;,  },]copy// will not work as expected and instead call fnToTestexport default {  fn: fnToTest,  expect: is.function,  info: &#39;function is a function&#39;,}multiple testsmultiple tests can be created by exporting an array of single test objects.copyexport default {  multipleTests: [    { fn: () =&gt; true, expect: true, info: &#39;expect true to be true&#39; },    { fn: () =&gt; false, expect: false, info: &#39;expect false to be false&#39; },  ]}multiple tests can also be created by exporting an array of tests.copyexport default [    { fn: () =&gt; true, expect: true, info: &#39;expect true to be true&#39; },    { fn: () =&gt; false, expect: false, info: &#39;expect false to be false&#39; },  ]promisescopyimport { promise, is } from &#39;@magic/test&#39;export default [  // kinda clumsy, but works. until you try handling errors.  {    fn: new Promise(cb =&gt; setTimeOut(() =&gt; cb(true), 2000)),    expect: true,    info: &#39;handle promises&#39;,  },  // better!  {    fn: promise(cb =&gt; setTimeOut(() =&gt; cb(null, true), 200)),    expect: true,    info: &#39;handle promises in a nicer way&#39;,  },  {    fn: promise(cb =&gt; setTimeOut(() =&gt; cb(new Error(&#39;error&#39;)), 200)),    expect: is.error,    info: &#39;handle promise errors in a nice way&#39;,  },]callback functionscopyimport { promise, is } from &#39;@magic/test&#39;const fnWithCallback = (err, arg, cb) =&gt; cb(err, arg)export default [  {    fn: promise(cb =&gt; fnWithCallback(null, true, cb)),    expect: true    info: &#39;handle callback functions as promises&#39;,  },  {    fn: promise(cb =&gt; fnWithCallback(new Error(&#39;oops&#39;), true, cb)),    expect: is.error,    info: &#39;handle callback function error as promise&#39;,  },]hooksrun functions before and/or after individual testcopyconst after = () =&gt; {  global.testing = &#39;Test has finished, cleanup.&#39;}const before = () =&gt; {  global.testing = false  // if a function gets returned,  // this function will be executed once the test finished.  return after}export default [  {    fn: () =&gt; { global.testing = &#39;changed in test&#39; },    // if before returns a function, it will execute after the test.    before,    after,    expect: () =&gt; global.testing === &#39;changed in test&#39;,  },]suite hooksrun functions before and/or after a suite of testscopyconst afterAll = () =&gt; {  // Test has finished, cleanup.&#39;  global.testing = undefined}const beforeAll = () =&gt; {  global.testing = false  // if a function gets returned,  // this function will be executed once the test suite finished.  return afterAll}export default [  {    fn: () =&gt; { global.testing = &#39;changed in test&#39; },    // if beforeAll returns a function, it will execute after the test suite.    beforeAll,    // this is optional and can be omitted if beforeall returns a function.    // in this example, afterAll will trigger twice.    afterAll,    expect: () =&gt; global.testing === &#39;changed in test&#39;,  },]magic modules@magic-modules assume all html tags to be globally defined.
to create those globals for your test and check if a @magic-module returns the correct markup, just add an html: true flag to the test:copyconst expect = [  &#39;i&#39;,  [    { class: &#39;testing&#39; },    &#39;testing&#39;,  ],]const props = { class: &#39;testing&#39; }export default [  // note that fn is a wrapped function, we can not call i directly as we could other functions  {    fn: () =&gt; i(props, &#39;testing&#39;),    expect,    info: &#39;magic/test can now test html&#39;,  },]Utility Belt@magic/test exports some utility functions that make working with complex test workflows simpler.curryCurrying can be used to split the arguments of a function into multiple nested functions.This helps if you have a function with complicated arguments
that you just want to quickly shim.copyimport { curry } from &#39;@magic/test&#39;const compare = (a, b) =&gt; a === bconst curried = curry(compare)const shimmed = curried(&#39;shimmed_value&#39;)export default {  fn: shimmed(&#39;shimmed_value&#39;),  expect: true,  info: &#39;expect will be called with a and b and a will equal b&#39;,}valsexports some javascript types. more to come.
will sometime in the future be the base of a fuzzer.promisesHelper function to wrap nodejs callback functions and promises with ease.&#39;
Handle the try/catch steps internally and return a resolved or rejected promise.&#39;copyimport { promise, is } from &#39;@magic/test&#39;export default [  {    fn: promise(cb =&gt; setTimeOut(() =&gt; cb(null, true), 200)),    expect: true,    info: &#39;handle promises in a nice way&#39;,  },  {    fn: promise(cb =&gt; setTimeOut(() =&gt; cb(new Error(&#39;error&#39;)), 200)),    expect: is.error,    info: &#39;handle promise errors in a nice way&#39;,  },]cssexports @magic/css,
which allows parsing and stringification of css-in-js objects.trycatchallows to test functions without bubbling the errors up into the runtimecopyimport { is, tryCatch } from &#39;@magic/test&#39;const throwing = () =&gt; throw new Error(&#39;oops&#39;)const healthy = () =&gt; trueexport default [  {    fn: tryCatch(throwing()),    expect: is.error,    info: &#39;function throws an error&#39;,  },  {    fn: tryCatch(healthy()),    expect: true,    info: &#39;function does not throw&#39;  },]usagejscopy// test/index.mjsimport run from &#39;@magic/test&#39;const tests = {  lib: [    { fn: () =&gt; true, expect: true, info: &#39;Expect true to be true&#39; }  ],}run(tests)clipackage.json (recommended)add the magic/test bin scripts to package.jsoncopy{  &quot;scripts&quot;: {    &quot;test&quot;: &quot;t -p&quot;,    &quot;coverage&quot;: &quot;t&quot;,  },  &quot;devDependencies&quot;: {    &quot;@magic/test&quot;: &quot;github:magic/test&quot;  }}then use the npm run scriptscopynpm testnpm run coverageGlobally (not recommended):you can install this library globally,
but the recommendation is to add the dependency and scripts to the package.json file.this both explains to everyone that your app has these dependencies
as well as keeping your bash free of cluttercopynpm i -g @magic/test// run tests in production modet -p// run tests and get coverage in verbose modetThis library tests itself, have a look at the testsCheckout @magic/types
and the other magic libraries for more test examples.made with a few bits of magic